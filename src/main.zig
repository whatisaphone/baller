const builtin = @import("builtin");
const std = @import("std");

const build_options = @import("build_options");

const build = @import("build.zig");
const dump = @import("dump.zig");
const extract = @import("extract.zig");
const saveload_dump = @import("saveload_dump.zig");
const talkie_build = @import("talkie_build.zig");
const talkie_extract = @import("talkie_extract.zig");

pub fn main() !u8 {
    runCli() catch |err| {
        if (err == error.CommandLine) {
            try std.io.getStdErr().writeAll(usage);
            return 1;
        }
        if (err == error.CommandLineReported or err == error.Reported) {
            return 1;
        }
        return err;
    };
    return 0;
}

fn runCli() !void {
    var debug_allocator: std.heap.DebugAllocator(.{}) = .init;
    const allocator = if (std.debug.runtime_safety)
        debug_allocator.allocator()
    else
        std.heap.smp_allocator;
    defer if (std.debug.runtime_safety)
        std.debug.assert(debug_allocator.deinit() == .ok);

    const args = try std.process.argsAlloc(allocator);
    defer std.process.argsFree(allocator, args);

    if (args.len < 1 + 1)
        return error.CommandLine;

    const command = args[1];

    if (std.mem.eql(u8, command, "help") or
        std.mem.eql(u8, command, "-h") or
        std.mem.eql(u8, command, "--help"))
    {
        try std.io.getStdOut().writeAll(usage);
    } else if (std.mem.eql(u8, command, "version") or
        std.mem.eql(u8, command, "-v") or
        std.mem.eql(u8, command, "--version"))
    {
        try std.io.getStdOut().writeAll(build_options.version);
    } else if (std.mem.eql(u8, command, "build")) {
        try build.runCli(allocator, args[2..]);
    } else if (std.mem.eql(u8, command, "dump")) {
        try dump.runCli(allocator, args[2..]);
    } else if (std.mem.eql(u8, command, "extract")) {
        try extract.runCli(allocator, args[2..]);
    } else if (std.mem.eql(u8, command, "saveload")) {
        if (args.len < 1 + 2)
            return error.CommandLine;
        const subcommand = args[2];
        if (std.mem.eql(u8, subcommand, "dump")) {
            try saveload_dump.runCli(allocator, args[3..]);
        } else {
            return error.CommandLine;
        }
    } else if (std.mem.eql(u8, command, "talkie")) {
        if (args.len < 1 + 2)
            return error.CommandLine;
        const subcommand = args[2];
        if (std.mem.eql(u8, subcommand, "build")) {
            try talkie_build.runCli(allocator, args[3..]);
        } else if (std.mem.eql(u8, subcommand, "extract")) {
            try talkie_extract.runCli(allocator, args[3..]);
        } else {
            return error.CommandLine;
        }
    } else {
        return error.CommandLine;
    }
}

const usage =
    \\Baller <https://github.com/whatisaphone/baller> licensed under AGPL 3.0
    \\
    \\A modding tool for Backyard Sports games.
    \\
    \\Usage:
    \\
    \\baller help: Show help
    \\
    \\baller version: Show version
    \\
    \\baller extract <index> <output>
    \\
    \\    <index>       Path to index file ending in .he0
    \\    <output>      Path to output directory
    \\    --symbols=
    \\    --script=disassemble|decompile
    \\    --annotate
    \\    --rmim=raw|decode
    \\    --scrp=raw|decode
    \\    --encd=raw|decode
    \\    --excd=raw|decode
    \\    --lscr=raw|decode
    \\    --lsc2=raw|decode
    \\    --awiz=raw|decode
    \\    --mult=raw|decode
    \\    --akos=raw|decode
    \\
    \\baller build <project> <output>
    \\
    \\    <project>     Path to project.txt, typically generated by baller
    \\                  extract
    \\    <output>      Path to output file ending in .he0
    \\
    \\baller talkie extract <input> <output>
    \\
    \\    <input>       Path to talkie file ending in .he2
    \\    <output>      Path to output directory
    \\
    \\baller talkie build <manifest> <output>
    \\
    \\    <manifest>    Path to talkies.txt, typically generated by baller
    \\                  talkie extract
    \\    <output>      Path to output file ending in .he2
    \\
    \\baller dump <output>
    \\
    \\                  (reads from stdin)
    \\    <output>      Path to output directory
    \\    -x=|--xor=    XOR key
    \\
    \\baller saveload dump <index> <savegame>
    \\
    \\                  (writes to stdout)
    \\
;

comptime {
    // Sorry, IBM mainframe users
    std.debug.assert(builtin.cpu.arch.endian() == .little);
}

test {
    _ = @import("tests.zig");
    _ = @import("tests2.zig");
    _ = @import("tests_compile_errors.zig");
    _ = @import("tests_decompile.zig");
}
